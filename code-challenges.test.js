// ASSESSMENT 3: Coding practical questions with Jest

// Please read all questions thoroughly
// Pseudo coding is REQUIRED
// If you get stuck, please leave comments to help us understand your thought process

// Use test driven development to complete the following questions
// Add appropriate dependencies: $ yarn add jest

// Reminder: The test will call your function
// Run the file with the following command: $ yarn jest


// --------------------1) Create a function that takes in a number (greater than 2) and returns an array that length containing the numbers of the Fibonacci sequence.
//Red-Green Refactor

// a) Create a test with expect statements for each of the variables provided.

//Got the Rowdy Red FAIL banner!!!
//describe method that lists the name of the function with arrow syntax
describe("fibonacci", () => {

  //test/it method that describes that the fibonacci() function will take in a number (greater than 2) and returns an array that length containing the numbers of the Fibonacci sequence
  it("take in a number > 2 and return an array that length containing the numbers of the Fibonacci sequence", () => {

    //expect method calling on the fibonacci() function, followed by the .toEqual() matcher that checks the expected output to be an array that length containing the numbers of the Fibonacci sequence
    expect(fibonacci(6)).toEqual([1, 1, 2, 3, 5, 8])
    expect(fibonacci(10)).toEqual([1, 1, 2, 3, 5, 8, 13, 21, 34, 55])
  })
})
// Example input: 6
// Expected output: [1, 1, 2, 3, 5, 8]

// Example input: 10
// Expected output: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]



// b) Create the function that makes the test pass.

//Minty Green PASS Banner was a delight to see. This exercise reminded me to play around with what I have and not trahed it if it doesn't work at first. Whew!
//Declare the function as what was placed in the test created. Place the parameter as stated in the test.
const fibonacci = (num) => {
  //Use methods to create an array that will perform the Fibonacci sequence which means a series of number as the result of adding up the two numbers before it.
  // Research----> The Fibonacci numbers are generated by setting F0 = 0, F1 = 1, and then using the recursive formula Fn = Fn-1 + Fn-2....my brain was ready to panic but looking back at the problem. When talking about the placement of things in an array we can look at index. So the math equation for my formual will involve the number at the two indexes preceding the fibonacci number in the sequence. Need an array variable. The array will contain the starting points of the fibonacci sequence of `1, 1`...my brain would not rest with the possibility of a number being less than two. So many ways to enter conflicting info. I will stick to the number aspect
  if (num <= 2) {
    return "Please enter a number > 2"
  } else {
  let arrayFib = [1, 1];
  //going to use for loop and push method to add a series of numbers in the fibonacci sequence using an equation to adding the preceeding numbers...add to play around with the starting number on i. `0` and `1` kept giving me `NAN` in my array. Never mind looking at my equation it makes sense (2-2)+(2-1) anything less will be negative...Lightbulb!!! The equation will be repeated until the array reaches the length of the number input.
  for(let a = 2; a < num; a++) {
    arrayFib.push(arrayFib[a - 2] + arrayFib[a - 1]);
    }
    ///that arrow function needs a return. I want the fibonacci array to be displayed.
    return arrayFib;
      }
  }
    //console.log those results
   console.log(fibonacci(6));
   console.log(fibonacci(10));
   console.log(fibonacci(0));


// --------------------2) Create a function that takes in an array and returns a new array of only odd numbers sorted from least to greatest.

// a) Create a test with expect statements for each of the variables provided.

//describe method that lists the name of the function with arrow syntax
describe("oddOrder", () => {

  //test/it method that takes in an array and returns a new array of only odd numbers sorted from least to greatest
  it("takes in an array and returns a new array of only odd numbers sorted from least to greatest", () => {
    //test the given variables
    var fullArr1 = [4, 9, 0, "7", 8, true, "hey", 7, 199, -9, false, "hola"]
    var fullArr2 = ["hello", 7, 23, -823, false, 78, null, "67", 6, "number"]

    //expect method calling on the oddOrder() function, followed by the .toEqual() matcher that checks the expected output to be an array of only odd numbers sorted from least to greatest
    expect(oddOrder(fullArr1)).toEqual([-9, 7, 9, 199])
    expect(oddOrder(fullArr2)).toEqual([-823, 7, 23])
  })
})
var fullArr1 = [4, 9, 0, "7", 8, true, "hey", 7, 199, -9, false, "hola"]
// Expected output: [-9, 7, 9, 199]

var fullArr2 = ["hello", 7, 23, -823, false, 78, null, "67", 6, "number"]
// Expected output: [-823, 7, 23]


// b) Create the function that makes the test pass.

//Declare function with arrow syntax and parameter
//const oddOrder = (array) => {
  //use conditional statement with `typeof()`, `.filter()`, and `%2` to find odd numbers and Mathmin() to arrange them in least to greatest...with some thought I will make two arrays to filter out numbers and then odd. Had to go back to the drawing board. More research
  // if (typeof(value) === "number") {
  // // let oddArray = numArray.filter(value%2 !== 0); Not working...more research.
  //***output the array in ascending order using Mathmin...Woops. I need sort instead for a full array. Research---->`.sort(function(a, b){return a-b})` will give an ascending order for numbers. Using that anonymous function
  // return array.sort(function(a, b){return a-b})};
  //So this variable only removed the even numbers without the typeof conditional statement...
//   let oddArray = array.filter( function(value){
//     if (typeof value === "number") {return value%2 !== 0};
//     } );
//   //Making a variable to remove strings and `true`
// //  let oddArray = noEven.filter(element => typeof element !== "string");
//   return oddArray.sort(function(a, b){return a-b});
// }
// console.log(oddOrder(fullArr1));
// console.log(oddOrder(fullArr2));

// Just placing the function in its completed state. I test and researched so much. Got to practice various structures. SO here is the Minty Green PASS banner approved code.
//Declare function with arrow syntax and array parameter
const oddOrder = (array) => {
  //After much battle I constructed a variable that used an anonymous function to take in an array an filter out only numbers and return only the odd. True and the strings only disappeared after placing a conditional statement in the anonymous function.
  let oddArray = array.filter( function(value){
    if (typeof value === "number") {return value%2 !== 0};
    } );
      //return the array in ascending order...much research on the sort function
      return oddArray.sort(function(b, c){return b-c});
}
  console.log(oddOrder(fullArr1));
  console.log(oddOrder(fullArr2));

// --------------------3) Create a function that takes in an array and returns an array of the accumulating sum. An empty array should return an empty array.

// a) Create a test with expect statements for each of the variables provided.

//describe method that lists the name of the function with arrow syntax
describe("sumYou", () => {

  //test/it method that takes in an array and returns an array of the accumulating sum. An empty array should return an empty array
  it("takes in an array and returns an array of the accumulating sum or an empty array", () => {
    //test the given variables
    var numbersToAdd1 = [2, 4, 45, 9]
    var numbersToAdd2 = [0, 7, -8, 12]
    var numbersToAdd3 = []

    //expect method calling on the oddOrder() function, followed by the .toEqual() matcher that checks the expected output to be an array of only odd numbers sorted from least to greatest
    expect(sumYou(numbersToAdd1)).toEqual([2, 6, 51, 60])
    expect(sumYou(numbersToAdd2)).toEqual([0, 7, -1, 11])
    expect((numbersToAdd3)).toEqual([])
  })
})

var numbersToAdd1 = [2, 4, 45, 9]
// Excpected output: [2, 6, 51, 60]

var numbersToAdd2 = [0, 7, -8, 12]
// Expected output: [0, 7, -1, 11]

var numbersToAdd3 = []
// Expected output: []

// b) Create the function that makes the test pass.
//Declare function name with array parameter.
const sumYou = (arr) => {
      //conditional statements takes in an array and returns an array of the accumulating sum or an empty array....attempting tenary operator
      // })
      //using .map() and addition for arrays with values as string interpolation. None of that worked. Research time.
  let ans = 0;
  let sumArr = arr.length < 1? (
    []
  ) : (
        //    arr.map(function(d, e){return d + e}
        //output -------> [ 2, 5, 47, 12 ]
        // [ 0, 8, -6, 15 ]
        // []
        //Got a hold bunch of wrong. Glad that it tested. Now to get the wording correct. I really want to get the hang of these HOF and ternary operators. I see now that I was telling it to add the value of the index to the value. Making a variable to start adding 0 to the first value. Keeping map to iterate the adding the answer to the next value. Whew! I am proud of this work. I completed it 10 pm. I took breaks too.
    arr.map(d=>{
      return ans + d
    })
  );
  return sumArr;
}

console.log(sumYou(numbersToAdd1));
console.log(sumYou(numbersToAdd2));
console.log(sumYou(numbersToAdd3));
